# rust-in-action

## 基本概念

### 内存 —— 堆、栈

在编译时，一切无法确定大小或者大小可以改变的数据，都无法**安全地**放在栈上，**最好**放在堆上。
> 对于存于栈上的值，它的大小在编译期就需要确定。栈上存储的变量的生命周期在当前调用栈的作用域内，无法跨调用栈引用

> 可变参数的函数是一个很好的例子。对于 Java，可变参数 String... a 是 String[] 的语法糖，它是放在堆上的。在 C 语言里，这个行为是未定义的，它只是定义了你可以通过 var_start / var_end 来获得可变参数的起始位置，以及最终结束可变参数的访问。但 gcc 的实现将可变参数放在栈上（估计是为了性能）。比如 C，你可以用 var_start / var_end 获取可变参数，但如果不小心处理， 会导致访问栈上的垃圾内容，甚至导致程序崩溃。@see:https://time.geekbang.org/discuss/detail/307626

除了动态大小的内存需要被分配到堆上外，动态生命周期的内存也需要分配到堆上。
> 堆可以存入大小未知或者动态伸缩的数据类型。堆上存储的变量，其生命周期从分配后开始，一直到释放时才结束，因此堆上的变量允许在多个调用栈之间引用

> ps: 栈上存放的数据是静态的，固定大小，固定生命周期(即使可以支持动态分配，其大小是受限的，受栈帧大小限制，Linux默认8M，同时生命周期也是固定的，比如c99中支持栈上动态分配)；堆上存放的数据是动态的，不固定大小，不固定生命周期

#### 堆问题

- 堆内存忘记释放，内存泄漏
- 属于共享内存区域，当多线程访问时可能出现堆越界（heap out of bounds）问题（写和读）
- 如果堆上内存被释放，但栈上指向堆上内存的相应指针没有被清空，就有可能发生使用已释放内存（use after free）的情况

### 数据

值和类型、指针和引用

#### 值和类型

严谨地说，类型是对值的区分，它包含了值在内存中的长度、对齐以及值可以进行的操作等信息。一个值是符合一个特定类型的数据的某个实体。比如 64u8，它是 u8 类型，对应一个字节大小、取值范围在 0～255 的某个整数实体，这个实体是 64。

这里你要注意，值是无法脱离具体的类型讨论的。同样是内存中的一个字节 0x40，如果其类型是 ASCII char，那么其含义就不是 64，而是 @ 符号。

#### 指针和引用

在内存中，一个值被存储到内存中的某个位置，这个位置对应一个内存地址。而指针是一个持有内存地址的值，可以通过解引用（dereference）来访问它指向的内存地址，理论上可以解引用到任意数据类型。

引用（reference）和指针非常类似，不同的是，引用的解引用访问是受限的，它只能解引用到它引用数据的类型，不能用作它用。比如，指向 42u8 这个值的一个引用，它解引用的时候只能使用 u8 数据类型。

### 代码

函数、方法、闭包、接口和虚表

### 运行方式

并发并行、同步异步和Promise|async|await

### 编程范式

泛型编程