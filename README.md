# rust-in-action

## 内存-堆、栈

在编译时，一切无法确定大小或者大小可以改变的数据，都无法**安全地**放在栈上，**最好**放在堆上。
> 对于存于栈上的值，它的大小在编译期就需要确定。栈上存储的变量的生命周期在当前调用栈的作用域内，无法跨调用栈引用

> 可变参数的函数是一个很好的例子。对于 Java，可变参数 String... a 是 String[] 的语法糖，它是放在堆上的。在 C 语言里，这个行为是未定义的，它只是定义了你可以通过 var_start / var_end 来获得可变参数的起始位置，以及最终结束可变参数的访问。但 gcc 的实现将可变参数放在栈上（估计是为了性能）。比如 C，你可以用 var_start / var_end 获取可变参数，但如果不小心处理， 会导致访问栈上的垃圾内容，甚至导致程序崩溃。@see:https://time.geekbang.org/discuss/detail/307626

除了动态大小的内存需要被分配到堆上外，动态生命周期的内存也需要分配到堆上。
> 堆可以存入大小未知或者动态伸缩的数据类型。堆上存储的变量，其生命周期从分配后开始，一直到释放时才结束，因此堆上的变量允许在多个调用栈之间引用

> ps: 栈上存放的数据是静态的，固定大小，固定生命周期(即使可以支持动态分配，其大小是受限的，受栈帧大小限制，Linux默认8M，同时生命周期也是固定的，比如c99中支持栈上动态分配)；堆上存放的数据是动态的，不固定大小，不固定生命周期

### 堆问题

- 堆内存忘记释放，内存泄漏
- 属于共享内存区域，当多线程访问时可能出现堆越界（heap out of bounds）问题（写和读）
- 如果堆上内存被释放，但栈上指向堆上内存的相应指针没有被清空，就有可能发生使用已释放内存（use after free）的情况
